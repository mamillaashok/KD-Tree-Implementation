# -*- coding: utf-8 -*-
"""Kd_tree_implementation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q4UyQYmvxPkKDkjzhTfH0OEYtOo9Hkcc

# **GPU Accelerated KD-Tree Algotithm N-Nearest Neighbhour Search**

# Input feature-1

1.   provide input to user for entering minimum and maximum of the respective 
     list size.
2.   consider those inputs and create a random value list.
"""

import random
from collections import namedtuple
from operator import itemgetter
from pprint import pformat

class List_creation:
    def __init__(self, size_of_list, minimum_value, maximum_value):
        self.size_of_list = size_of_list
        self.minimum_value = minimum_value
        self.maximum_value = maximum_value

    def create(self, size_of_list, minimum_value, maximum_value):
        p = []

        for i in range(size_of_list):
            # coordinates as integer values
            p.append((random.randint(minimum_value, maximum_value),
                      random.randint(minimum_value, maximum_value)))

        return p

minimum_value = int(input("Enter Minimum Value"))
maximum_value = int(input("Enter Maximum Value"))
size_of_list = int(input("Enter size of the list"))
random_list = List_creation(size_of_list, minimum_value, maximum_value)
coordinates_list = random_list.create(size_of_list, minimum_value, maximum_value)
print(coordinates_list)
a1 = len(coordinates_list)
print(a1)

class Tree_structure(namedtuple('Tree_structure', 'location left_node  right_node')):
    def __repr__(self):
        return pformat(tuple(self))


def kdtree_function(coordinates_list, d=0):
    try:
        current_point = len(coordinates_list[0])
    except IndexError:
        return None
    cutting_dim = d % current_point
    center = len(coordinates_list) // 2
    coordinates_list.sort(key=itemgetter(cutting_dim))
    return Tree_structure(
        location=coordinates_list[center],
        left_node=kdtree_function(coordinates_list[:center], d + 1),
        right_node=kdtree_function(coordinates_list[center + 1:], d + 1)
    )


upd = kdtree_function(coordinates_list)
print(upd)

import matplotlib.pyplot as plt

delta = 2
plane_line_width = [4., 3.5, 3., 2.5, 2., 1.5, 1., .5, 0.3]


def visualize_tree(upd, mnx, mxx, mny, mxy, previous_node, branch, depth=0):
 

    cur_node = upd.location  
    left_branch = upd.left_node  
    right_branch = upd.right_node  

    if depth > len(plane_line_width) - 1:
        ln_width = plane_line_width[len(plane_line_width) - 1]
    else:
        ln_width = plane_line_width[depth]

    k = len(cur_node)
    axis = depth % k

    if axis == 0:

        if branch is not None and previous_node is not None:

            if branch:
                mxy = previous_node[1]
            else:
                mny = previous_node[1]

        plt.plot([cur_node[0], cur_node[0]], [mny, mxy], linestyle='-', color='green', linewidth=ln_width)

    elif axis == 1:

        if branch is not None and previous_node is not None:

            if branch:
                mxx = previous_node[0]
            else:
                mnx = previous_node[0]

        plt.plot([mnx, mxx], [cur_node[1], cur_node[1]], linestyle='dotted', color='black', linewidth=ln_width)

    # draw the current node
    plt.plot(cur_node[0], cur_node[1], 'D', color='black')

    # draw left and right branches of the current node
    if left_branch is not None:
        visualize_tree(left_branch, mnx, mxx, mny, mxy, cur_node, True, depth + 1)

    if right_branch is not None:
        visualize_tree(right_branch, mnx, mxx, mny, mxy, cur_node, False, depth + 1)


plt.figure("K-d Tree", figsize=(10., 10.))
plt.axis([minimum_value - delta, maximum_value + delta, minimum_value - delta, maximum_value + delta])

plt.xticks([i for i in range(minimum_value - delta, maximum_value + delta, 1)])
plt.yticks([i for i in range(minimum_value - delta, maximum_value + delta, 1)])

# draw the tree
visualize_tree(upd, minimum_value - delta, maximum_value + delta, minimum_value - delta, maximum_value + delta, None,
               None)

plt.title('K-D Tree Visualisation')

plt.show()
plt.close()

nearest_nn = None  # nearest neighbor (NN)
distance_nn = float('inf')  # distance from NN to target


def nearest_neighbor_search(upd, query_point, hr, distance, nearest=None, depth=0):
   

    global nearest_nn
    global distance_nn

    if upd is None:
        return

    k = len(query_point)

    cur_node = upd.location  # current tree's node
    left_branch = upd.left_node  # its left branch
    right_branch = upd.right_node  # its right branch

    nearer_kd = further_kd = None
    nearer_hr = further_hr = None
    left_hr = right_hr = None

    # Select axis based on depth so that axis cycles through all valid values
    axis = depth % k

    # split the hyperplane depending on the axis
    if axis == 0:
        left_hr = [hr[0], (cur_node[0], hr[1][1])]
        right_hr = [(cur_node[0], hr[0][1]), hr[1]]

    if axis == 1:
        left_hr = [(hr[0][0], cur_node[1]), hr[1]]
        right_hr = [hr[0], (hr[1][0], cur_node[1])]

    # check which hyperplane the target point belongs to
    if query_point[axis] <= cur_node[axis]:
        nearer_kd = left_branch
        further_kd = right_branch
        nearer_hr = left_hr
        further_hr = right_hr

    if query_point[axis] > cur_node[axis]:
        nearer_kd = right_branch
        further_kd = left_branch
        nearer_hr = right_hr
        further_hr = left_hr

    # check whether the current node is closer
    dist = (cur_node[0] - query_point[0]) ** 2 + (cur_node[1] - query_point[1]) ** 2

    if dist < distance:
        nearest = cur_node
        distance = dist

    # go deeper in the tree
    nearest_neighbor_search(nearer_kd, query_point, nearer_hr, distance, nearest, depth + 1)

    # once we reached the leaf node we check whether there are closer points
    # inside the hypersphere
    if distance < distance_nn:
        nearest_nn = nearest
        distance_nn = distance

    # a nearer point (px,py) could only be in further_kd (further_hr) -> explore it
    px = compute_closest_coordinate(query_point[0], further_hr[0][0], further_hr[1][0])
    py = compute_closest_coordinate(query_point[1], further_hr[1][1], further_hr[0][1])

    # check whether it is closer than the current nearest neighbor => whether a hypersphere crosses the hyperplane
    dist = (px - query_point[0]) ** 2 + (py - query_point[1]) ** 2

    # explore the further kd-tree / hyperplane if necessary
    if dist < distance_nn:
        nearest_neighbor_search(further_kd, query_point, further_hr, distance, nearest, depth + 1)

def compute_closest_coordinate(value, range_min, range_max):
    """ Compute the closest coordinate for the neighboring hyperplane
    :param value     coordinate value (x or y) of the target point
    :param range_min minimal coordinate (x or y) of the neighboring hyperplane
    :param range_max maximal coordinate (x or y) of the neighboring hyperplane
    :return x or y coordinate
    """

    v = None

    if range_min < value < range_max:
        v = value

    elif value <= range_min:
        v = range_min

    elif value >= range_max:
        v = range_max

    return v

import math
import numpy as np

tx = int(input('enter x coordinate'))
ty = int(input('enter y coordinate'))
# generate a random point on the grid
# point = (np.random.normal(random.randint(minimum_value, maximum_value), scale=0.5),
#          np.random.normal(random.randint(minimum_value, maximum_value), scale=0.5))
point = (tx, ty)
delta = 2

hr = [(minimum_value - delta, maximum_value + delta),
      (maximum_value + delta, minimum_value - delta)]  # initial splitting plane
max_dist = float('inf')

# find the nearest neighbor
nearest_neighbor_search(upd, point, hr, max_dist)

# draw the given point
plt.figure("K-d Tree", figsize=(10., 10.))
plt.plot(point[0], point[1], marker='o', color='#ff007f')
plt.axis([minimum_value - delta, maximum_value + delta, minimum_value - delta, maximum_value + delta])

plt.xticks([i for i in range(minimum_value - delta, maximum_value + delta, 1)])
plt.yticks([i for i in range(minimum_value - delta, maximum_value + delta, 1)])
visualize_tree(upd, minimum_value - delta, maximum_value + delta, minimum_value - delta, maximum_value + delta, None,
               None)

plt.title('K-D Tree Visualisation')

circle = plt.Circle((point[0], point[1]), 0.3, facecolor='#ff007f', edgecolor='#ff007f', alpha=0.5)
plt.gca().add_patch(circle)

# making circle around the point
circle = plt.Circle((point[0], point[1]), math.sqrt(distance_nn), facecolor='#ffd83d', edgecolor='#ffd83d', alpha=0.5)
plt.gca().add_patch(circle)

# visualizing the indentified nearest neighbor
plt.plot(nearest_nn[0], nearest_nn[1], 'go')
circle = plt.Circle((nearest_nn[0], nearest_nn[1]), 0.3, facecolor='#33cc00', edgecolor='#33cc00', alpha=0.5)
plt.gca().add_patch(circle)
plt.show()



import numpy as np
from time import time
from scipy.spatial import KDTree as kd
from functools import reduce
import matplotlib.pyplot as plt

def euclid(c, cs, r):
    return ((cs[:,0] - c[0]) ** 2 + (cs[:,1] - c[1]) ** 2 + (cs[:,2] - c[2]) ** 2) < r ** 2

def find_nn_naive(cells, radius):
    for i in range(len(cells)):
        cell = cells[i]
        cands = euclid(cell, cells, radius)

def find_nn_kd_seminaive(cells, radius):
    tree = kd(cells)
    for i in range(len(cells)):
        res = tree.query_ball_point(cells[i], radius)

def find_nn_kd_by_tree(cells, radius):
    tree = kd(cells)
    return tree.query_ball_tree(tree, radius)

min_iter = 5000
max_iter = 10000
step_iter = 1000

rng = range(min_iter, max_iter, step_iter)
elapsed_naive = np.zeros(len(rng))
elapsed_kd_sn = np.zeros(len(rng))
elapsed_kd_tr = np.zeros(len(rng))

ei = 0
for i in rng:
    random_cells = np.random.rand(i, 3) * 400.
    t = time()
    r1 = find_nn_naive(random_cells, 50.)
    elapsed_naive[ei] = time() - t
    t = time()
    r2 = find_nn_kd_seminaive(random_cells, 50.)
    elapsed_kd_sn[ei] = time() - t
    t = time()
    r3 = find_nn_kd_by_tree(random_cells, 50.)
    elapsed_kd_tr[ei] = time() - t
    ei += 1



plt.plot(rng, elapsed_naive, label='naive')
# plt.plot(rng, elapsed_kd_sn, label='semi kd')
plt.plot(rng, elapsed_kd_tr, label='full kd')
plt.legend()
plt.show(block=True)

import numpy as np
import scipy as sp
import numba as nb

import scipy.spatial

SCALE = 400.0
RADIUS = 50.0 


def find_nn_np(points, radius=RADIUS, p=2):
    n_points, n_dim = points.shape
    result = np.empty(n_points, dtype=object)
    for i in range(n_points):
        result[i] = np.where(np.sum(np.abs(points - points[i:i + 1, :]) ** p, axis=1) < radius ** p)[0].tolist()
    return result


def find_nn_kd_tree(points, radius=RADIUS):
    tree = sp.spatial.KDTree(points)
    return tree.query_ball_point(points, radius)


def find_nn_kd_tree_cy(points, radius=RADIUS):
    tree = sp.spatial.cKDTree(points)
    return tree.query_ball_point(points, radius)


@nb.jit
def neighbors_indexes_jit(radius, center, points, p=2):
    n_points, n_dim = points.shape
    k = 0
    res_arr = np.empty(n_points, dtype=nb.int64)
    for i in range(n_points):
        dist = 0.0
        for j in range(n_dim):
            dist += abs(points[i, j] - center[j]) ** p
        if dist < radius ** p:
            res_arr[k] = i
            k += 1
    return res_arr[:k]


@nb.jit(forceobj=True, parallel=True)
def find_nn_jit(points, radius=RADIUS):
    n_points, n_dim = points.shape
    result = np.empty(n_points, dtype=object)
    for i in nb.prange(n_points):
        result[i] = neighbors_indexes_jit(radius, points[i], points, 2)
    return result

def gen_input(n, dim=2, scale=SCALE):
    return scale * np.random.rand(n, dim)


def equal_output(a, b):
    return all(sorted(a_i) == sorted(b_i) for a_i, b_i in zip(a, b))


funcs = find_nn_np, find_nn_jit, find_nn_kd_tree_cy


input_sizes = tuple(int(2 ** (2 + (1 * i) / 4)) for i in range(32, 32 + 16 + 1))
print('Input Sizes:\n', input_sizes, '\n')

runtimes, input_sizes, labels, results = benchmark(funcs, gen_input=gen_input, equal_output=equal_output,input_sizes=input_sizes)


plot_benchmarks(runtimes, input_sizes, labels, units='s')

import numpy as np
from scipy import spatial
import networkx as nx
import matplotlib.pyplot as plt
nnodes = 100
r = 0.30
positions =  np.random.rand(nnodes,2)
kdtree = spatial.KDTree(positions)
pairs = kdtree.query_pairs(r)
G = nx.Graph()
G.add_nodes_from(range(nnodes))
G.add_edges_from(list(pairs))
pos = dict(zip(range(nnodes),positions))
nx.draw(G,pos)
plt.show()

import numpy as np
import scipy as sp
import numba as nb

import scipy.spatial

SCALE = 400.0
RADIUS = 50.0 


def find_nn_np(points, radius=RADIUS, p=2):
    n_points, n_dim = points.shape
    result = np.empty(n_points, dtype=object)
    for i in range(n_points):
        result[i] = np.where(np.sum(np.abs(points - points[i:i + 1, :]) ** p, axis=1) < radius ** p)[0].tolist()
    return result


def find_nn_kd_tree(points, radius=RADIUS):
    tree = sp.spatial.KDTree(points)
    return tree.query_ball_point(points, radius)


def find_nn_kd_tree_cy(points, radius=RADIUS):
    tree = sp.spatial.cKDTree(points)
    return tree.query_ball_point(points, radius)


@nb.jit
def neighbors_indexes_jit(radius, center, points, p=2):
    n_points, n_dim = points.shape
    k = 0
    res_arr = np.empty(n_points, dtype=nb.int64)
    for i in range(n_points):
        dist = 0.0
        for j in range(n_dim):
            dist += abs(points[i, j] - center[j]) ** p
        if dist < radius ** p:
            res_arr[k] = i
            k += 1
    return res_arr[:k]


@nb.jit(forceobj=True, parallel=True)
def find_nn_jit(points, radius=RADIUS):
    n_points, n_dim = points.shape
    result = np.empty(n_points, dtype=object)
    for i in nb.prange(n_points):
        result[i] = neighbors_indexes_jit(radius, points[i], points, 2)
    return result